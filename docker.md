# Docker Cheat Sheet â€” Fundamentals, Best Practices & Troubleshooting

A concise README-style reference covering Docker fundamentals, Dockerfile and image management, storage, networking, security, troubleshooting, and advanced concepts. This is organized as Q&A for quick lookup.

Table of Contents
- Category 1: Docker Fundamentals & Architecture
- Category 2: Dockerfile & Image Management
- Category 3: Storage & Volumes
- Category 4: Networking
- Category 5: Security & Best Practices
- Category 6: Troubleshooting & Real-time Scenarios
- Category 7: Advanced Concepts

---

## Category 1: Docker Fundamentals & Architecture

1. What is Docker and how does it differ from traditional virtualization?
- Answer:
  - Docker is a platform for developing, shipping, and running applications in containers.
  - Key differences:
    - Virtualization: VMs run a full guest OS on a hypervisor, resulting in higher resource overhead.
    - Containers: Share the host OS kernel, run isolated processes, are lightweight and fast.
    - Startup time: VMs take minutes, containers start in seconds.
    - Resource usage: VMs can require GBs of memory; containers usually require MBs.

2. Explain Docker architecture and its main components.
- Answer:
  - Docker Daemon (dockerd): Background service that manages images, containers, networks, and volumes.
  - Docker Client (CLI): The `docker` command used by users to interact with the daemon.
  - Docker Images: Read-only templates used to create containers.
  - Docker Containers: Runnable instances of images (with a writable layer).
  - Docker Registry: Stores images (Docker Hub or private registries).
  - Dockerfile: Script containing instructions to build images.

3. What is the difference between a Docker image and container?
- Answer:
  - Image: Immutable, read-only template bundling application code and dependencies. Built from a Dockerfile.
  - Container: A running (or stopped) instance of an image with a writable layer for runtime changes.

4. Explain Docker container lifecycle states.
- Answer:
  - Created: Container entry exists but not started.
  - Running: Container process is executing.
  - Paused: Process execution suspended (cgroups freezer).
  - Stopped/Exited: Process terminated; container metadata remains.
  - Removed: Container deleted from the system.

---

## Category 2: Dockerfile & Image Management

5. What is a Dockerfile and explain common instructions?
- Answer:
  - A Dockerfile is a text file that contains instructions to build a Docker image.
  - Common instructions:
    - `FROM`: Specify base image.
    - `RUN`: Execute commands during build (creates a layer).
    - `COPY` / `ADD`: Copy files from build context into the image (`ADD` supports URLs and tar auto-extract).
    - `WORKDIR`: Set working directory.
    - `EXPOSE`: Document the ports the container listens on.
    - `CMD` / `ENTRYPOINT`: Default command and/or entrypoint to run when container starts.

6. What is the difference between CMD and ENTRYPOINT?
- Answer:
  - `CMD`: Provides default arguments for the container command; can be overridden with `docker run ...`.
  - `ENTRYPOINT`: Defines the executable that will always run; `CMD` then supplies default arguments to that entrypoint.
  - Best practice: Use `ENTRYPOINT` for the main application and `CMD` for default parameters.

7. How do you optimize Docker image size?
- Answer:
  - Use minimal base images (e.g., Alpine, distroless).
  - Combine `RUN` commands to reduce layers.
  - Use `.dockerignore` to exclude unnecessary files from the build context.
  - Clean package manager caches in the same `RUN` command that installs packages.
  - Use multi-stage builds to avoid bundling build-time dependencies.

8. What are multi-stage builds and why are they useful?
- Answer:
  - Multi-stage builds use multiple `FROM` statements. You can compile/build in one stage, then copy results into a smaller runtime image, producing smaller final images.
  - Example:
```dockerfile
# Build stage
FROM golang:1.19 AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp

# Final stage
FROM alpine:latest
COPY --from=builder /app/myapp /
CMD ["./myapp"]
```

---

## Category 3: Storage & Volumes

9. What are Docker volumes and when to use them?
- Answer:
  - Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.
  - Use cases:
    - Database storage
    - Configuration files
    - Shared data between containers
    - Backups and restores

10. Difference between bind mounts and named volumes?
- Answer:
  - Bind mounts: Map a directory or file from the host into the container. Highly dependent on host filesystem and path.
  - Named volumes (managed volumes): Docker-managed, stored in Docker's storage area, more portable across hosts (when orchestrated or migrated).
  - Use bind mounts for development, named volumes for production/persistence.

11. How do you manage sensitive data in Docker?
- Answer:
  - Docker Secrets (in Swarm mode) for secrets management.
  - Environment variables: convenient but not secure for sensitive data.
  - Mount secret files as read-only volumes.
  - Use external secret managers: HashiCorp Vault, AWS Secrets Manager, etc.

---

## Category 4: Networking

12. Explain Docker network types.
- Answer:
  - `bridge`: Default single-host network; containers on the same bridge can communicate.
  - `host`: Container shares the host network stack (no network namespace isolation).
  - `overlay`: Connects containers across multiple Docker daemons (used with Swarm/Kubernetes CNI equivalents).
  - `macvlan`: Assigns a MAC address to containers so they appear as physical devices on the network.
  - `none`: Disables networking for the container.

13. How do containers communicate with each other?
- Answer:
  - On the same bridge network: containers can reach each other by container name (Docker DNS).
  - Custom user-defined networks: DNS-based service discovery and better isolation.
  - Legacy `links` existed but are not recommended.
  - Containers on different hosts can talk via published ports or overlay networks.

14. What is Docker Compose and when to use it?
- Answer:
  - Docker Compose lets you define and run multi-container applications using a `docker-compose.yml` file.
  - Use cases:
    - Local development of multi-service apps.
    - Integration testing and simple multi-container deployments.
    - Not a full replacement for production orchestration (use orchestrators for large-scale deployments).

---

## Category 5: Security & Best Practices

15. What are Docker security best practices?
- Answer:
  - Run containers as a non-root user whenever possible.
  - Use minimal base images to reduce attack surface.
  - Scan images for vulnerabilities (e.g., Trivy, Snyk).
  - Use trusted base images and signed images when available.
  - Implement resource limits (CPU, memory).
  - Keep the Docker daemon and host OS up to date.
  - Use proper secrets management.

16. How do you limit container resources?
- Answer:
- Example:
```bash
docker run --memory=512m --cpus=1.5 --pids-limit=100 my-app
```

17. What is container scanning and why is it important?
- Answer:
  - Container scanning analyzes images for known vulnerabilities and misconfigurations.
  - Tools: Trivy, Clair, Docker Scout, Snyk.
  - Importance: Identifies security risks early, before images reach production.

---

## Category 6: Troubleshooting & Real-time Scenarios

18. Container is running but application isn't accessible. How to debug?
- Steps:
  - Check container logs: `docker logs <container_name>`
  - Verify port mapping: `docker ps` and ensure `-p` or `EXPOSE` are correct.
  - Exec into the container: `docker exec -it <container_name> sh` (or bash) and test services.
  - Check application configuration and environment variables.
  - Verify host/network firewall rules and connectivity.

19. How to debug a container that exits immediately?
- Steps:
  - Run interactively to reproduce: `docker run -it --rm <image> sh` (or override `CMD`).
  - Check exit code: `docker ps -a` then `docker inspect --format='{{.State.ExitCode}}' <container>`
  - Inspect logs: `docker logs <container_id>`
  - Check resource constraints and entrypoint/CMD syntax.

20. Docker build is failing due to space issues. How to resolve?
- Steps:
  - Clean up unused resources: `docker system prune` (use with caution; consider flags).
  - Remove dangling images: `docker image prune`
  - Check disk usage of Docker root (`/var/lib/docker` by default).
  - Use smaller base images and multi-stage builds.
  - Clean caches during build steps to avoid extra layers.

21. How to monitor Docker container performance?
- Answer:
  - `docker stats` for real-time resource metrics (CPU, memory, I/O, network).
  - `docker top <container>` to see processes inside container.
  - Centralized logging and monitoring: ELK stack, Prometheus + cAdvisor, Datadog, etc.

22. How to backup and restore Docker containers?
- Basic backup approach:
```bash
# Commit container state to an image
docker commit <container_name> backup_image
# Save the image to a tarball
docker save backup_image > backup.tar
```
- Restore:
```bash
docker load < backup.tar
docker run backup_image
```
- For data persistence use volumes and back up volume contents (e.g., tar the volume directory or use `docker run --rm -v my_volume:/data -v $(pwd):/backup alpine tar czf /backup/vol-backup.tgz /data`).

---

## Category 7: Advanced Concepts

23. What is Docker Swarm and how does it compare to Kubernetes?
- Answer:
  - Docker Swarm: Docker's native clustering/orchestration solution; simpler to setup.
  - Kubernetes: More feature-rich and flexible; larger ecosystem and steeper learning curve.
  - Comparison highlights:
    - Setup: Swarm is simpler; Kubernetes more complex but more powerful.
    - Scaling: Both support scaling; Kubernetes has richer scheduling and autoscaling capabilities.
    - Networking: Kubernetes offers more flexible networking constructs.
    - Ecosystem: Kubernetes has a larger community and tooling ecosystem.

24. Explain Docker build cache and how it works.
- Answer:
  - Docker caches each build layer. If an instruction and its inputs haven't changed, Docker can reuse the cached layer.
  - Cache invalidation occurs when:
    - The instruction changes.
    - The base image changes.
    - Files copied into the image change (COPY/ADD checks checksums).

25. What are .dockerignore files and why use them?
- Answer:
  - `.dockerignore` excludes files from the build context (like `.gitignore` for Docker).
  - Benefits:
    - Smaller build context and faster builds.
    - Avoids including sensitive or unnecessary files.
    - Prevents unnecessary cache invalidation.

26. How do you handle application configuration in Docker?
- Answer:
  - Environment variables.
  - Configuration files mounted as volumes.
  - Docker Configs (in Swarm mode).
  - External configuration services (Consul, etcd, Vault, AWS Parameter Store).

27. What is the difference between ADD and COPY?
- Answer:
  - `COPY`: Copies files and directories from the build context into the image (simple and predictable).
  - `ADD`: Like `COPY` but also supports extracting local tar archives and fetching remote URLs.
  - Best practice: Use `COPY` unless you specifically need `ADD` behavior.

28. How to reduce Docker image build time?
- Answer:
  - Leverage build cache effectively by ordering Dockerfile instructions from least to most frequently changing.
  - Use BuildKit for faster, parallel builds.
  - Minimize build context with `.dockerignore`.
  - Use smaller base images and multi-stage builds.
  - Use caching in CI/CD (e.g., registry cache, buildkit cache).

29. What are Docker health checks?
- Answer:
  - Health checks let Docker determine if an application inside a container is healthy.
  - Dockerfile example:
```dockerfile
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost/ || exit 1
```
  - Or provide a script that returns a proper exit code.

30. How do you update running containers without downtime?
- Strategies:
  - Build a new image version.
  - Use orchestration (Docker Swarm, Kubernetes) to perform rolling updates.
  - Blue-green deployments: switch traffic to a new set of instances after health checks pass.
  - Use a load balancer with health checks to drain and replace instances gracefully.
